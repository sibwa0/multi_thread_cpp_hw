# Задание: RAII action

1. Необходимо реализовать класс RAIIAction:
По выходе экземпляра класса из scope деструктор вызывает некоторую функцию, переданную экземлпяру на этапе создание объекта
(В примере ниже объекту класса cleanup передана функция some_free. Как завершится область видимости экземпляра должна сработать функция some_free)

2. Код должен быть покрыт юнит-тестами и интеграционными тестами. Название класса и его методов - CamelCase; объекты, переменные - snake_case.

3. Система сборки CMake

4. Инструкция сборки:

# Запуск
-- Cборка
~~~
mkdir build
cd build
cmake ..
make
~~~

-- Тесты (для запуска из build)
~~~
./tests/unit/test_raii_action
~~~

## RAII action (my task)

    	SomeType someResource;
    	some_init(&someResource); // C-style

    	RAIIAction cleanup([&someResource] {
          	    some_free(&someResource);
    	});


### NamedContainer (Зенин Виктор)
Сделайте объект-фабрику NamedContainer, которая отвечает следующей семантике:

// Имена полей. Считаем, что содержимое - строки
NamedContainer myC{ “field1”, “field2”, “field3” }; 

auto c1 = myC.create();
c1[“field1”] = “abc”; // OK
std::cout << t1[“field2”] << std::endl; // Пустая строка по умолчанию
c1[“XXX”] = “cdr”; // Exception - unknown name



### Комментарий к заданию
Достаточно реализации основных методов объекта, описанного в задании. Т.е. если у вас не будет, например, перегрузки конструктора с initializer_list, std::in_place или возможности использовать кастомный аллокатор - ничего страшного. Главное - реализовать основную идею.
Контейнеры должны быть шаблонными, если в задании не указано иное. Также в контейнерах/строках требуется реализовать итераторы


